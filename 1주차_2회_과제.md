## 1. 트랜잭션 isolcation level 정리

동시에 여러 트랜잭션의 처리 시 트랜잭션끼리 얼마나 고립되어 있는지를 나타내는 것이다.

다음은 isolation level의 종류이다.
1. Read Uncommitted
2. Read Committed
3. Repeatable Read
4. Serializable

#
Read Uncommitted는 Select 문장 수행 중 해당 데이터에 Shared Lock이 걸리지 않는다. 트랜잭션에 처리 중이거나 아직 Commit 되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다.

이는 데이터베이스의 일관성을 유지하는 것이 불가능하며 이로 인해 Dirty Read가 발생한다.

이 Dirty Read는 다른 트랜잭션에서 작업 후 Commit 하지 않은 채 Read 후 RollBack이 일어나 Read된 값과 RollBack으로 인한 이전 값이 다름으로 발생하는 경우를 말한다.

#
Read Commited는 Select 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸린다. 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 된다. Commit이 이루어진 트랜잭션만 조회가 가능하다. 대체로 여러 DB에서 기본적으로 사용되는 isolation level이다.

Non-Repeatable Read가 발생한다. 이 Non-Repeatable Read는 트랜잭션이 실행 되는 도중에 특정값을 여러번 조회할 때 조회 전과 후가 달라지는 현상이다. 처음 값을 읽은 후 다른 트랜잭션에서 값을 변경함으로 한 트랜잭션에서 읽은 값이 달라지면 정상적인 동작이 아니다.

#
Repeatable Read는 트랜잭션이 완료될 때까지 Select 문장이 사용되는 모든 데이터에 Shared Lock이 걸린다. 트랜잭션이 범위 내 조회한 데이터 내용이 항상 동일함을 보장한다. 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대해 수정이 불가능하다.

이제 Non-Repeatable Read는 해결 되었다. 그러나 Phantom Read가 발생한다. Phantom Read는 트랜잭션에서 Read 되었거나 되지 않았던 값에 대해 다른 트랜잭션이 조작할 경우 - 값이 사라지거나 수정 혹은 입력되는 경우 - 해당 값은 Read 시 없었어야 하거나 존재하는 값으로 갑작스럽게 나타난 값이다.

#
Serializable은 트랜잭션이 완료될 때까지 Select 문장이 사용되는 모든 데이터에 Shared Lock이 걸린다. 가장 엄격한 격리 수준으로 완벽한 읽기 일관성 모드를 제공한다. 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대해 수정 및 입력이 불가능하다.

위에 예시되었던 상황에 대해 오류는 사라졌다고 볼 수 있다. 
다만 이 단계는 한 트랜잭션이 오랫동안 값을 가지고 있는 경우 Lock이 걸려 다른 트랜잭션이 작업이 불가능하기 때문에 많은 부하가 걸릴 수도 있다.
#
## 2. Spring의 Transaction 기능 동작 원리
Spring이 제공하는 트랜잭션 핵심 기술이 3가지 있다.
1. 트랜잭션 동기화
2. 트랜잭션 추상화
3. AOP를 이용한 트랜잭션 분리

### 1. 트랜잭션 동기화
트랜잭션을 시작하기 위한 Connection 객체를 특별한 저장소에 보관해두고 필요할 때 꺼내쓸 수 있도록 하는 기술이다. 트랜잭션 동기화 저장소는 작업 쓰레드마다 Connection 객체를 독립적으로 관리하기 때문에, 멀티쓰레드 환경에서도 충돌이 발생할 가능성이 적다.

그러나 JDBC와 Hibernate의 기술은 Connection과 Session을 통한 연결을 사용하기 때문에 이 기술 종속적인 문제를 해결하기 위해 트랜잭션 관리 부분을 추상화 기술로 제공하고 있다.

### 2. 트랜잭션 추상화
트랜잭션 추상화는 Spring 제공 트랜잭션 경계 설정을 위한 추상 인터페이스 PlatformTransactionManager이 있다. 이 인터페이스를 통해 트랜잭션을 공유하고 커밋, 롤백할 수 있게 되었다. 그러나 트랜잭션 관리 코드들을 비즈니스 로직 코드에 작성해야 되는 문제가 있고 이 문제를 해결하기 위해 Spring의 AOP를 활용해 트랜잭션과 비즈니스 로직을 분리한다.

### 3. AOP를 통한 트랜잭션 분리
Spring에서는 트랜잭션 코드와 같은 부가 기능 코드가 존재하지 않는 것처럼 보이게 해당 로직을 클래스 밖으로 빼내 별도의 모듈로 만드는 AOP를 고안 및 적용하게 되었다. 이를 트랜잭션 어노테이션을 통해 지원하도록 설계되었다.