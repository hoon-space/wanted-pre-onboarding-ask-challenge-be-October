## 1. 트랜잭션 isolation 레벨 정리
isolation이란 데이터베이스 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질 4가지가 존재합니다.
1) 원자성(Atomicity) : 한 트랜잭션 내에서 실행한 작업들은 하나로 간주합니다.(모두 성공 또는 실패)
2) 일관성(Consistency) : 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 합니다.
3) 격리성(Isolation) : 동시에 실행되는 트랜잭션들이 서로 영향이 미치지 않아야 합니다.
4) 지속성(Durability) : 트랜잭션을 성공적으로 마치면 결과가 항상 저장되어야 합니다.

### READ_UNCOMMITTED
```
한 트랜잭션이 처리중인 커밋되지 않은 데이터를 다른 트랜잭션에서 접근 가능합니다.
DB에 커밋하지 않은, 즉 존재하지 않는 데이터를 읽는 현상을 Dirty Read라고 합니다.
데이터 정합성에 문제가 많아서 웬만하면 권장되지 않고 아예 지원하지 않는 경우도 있습니다.
Dirty Read가 가능하기 때문에 잘못된 데이터를 읽을 수 있습니다.
```
- A 트랜잭션이 데이터 1을 조회하여 2로 변경하고 아직 커밋하지 않음.
- B 트랜잭션이 동일한 데이터를 조회해서 2라는 값을 받음.(Dirty Read)
- A 트랜잭션에서 오류가 발생해서 데이터를 롤백.(2 -> 1)
- 실제 데이터는 1이지만 B 트랜잭션은 2라는 잘못된 데이터를 읽은 셈임.

### READ_COMMITTED
```
트랜잭션은 커밋한 데이터만 읽을 수 있습니다.
A 트랜잭션이 데이터를 변경해도 커밋하기 전이라면 B 트랜잭션은 변경되기 전의 데이터를 조회할 수 있습니다.
이때, B 트랜잭션은 Undo 영역에서 데이터를 가져옵니다.(MVCC - Multi Version Concurrency Control 참조)
매 조회 시마다 새로운 스냅샷을 뜨기 때문에 다른 트랜잭션이 커밋한 후 다시 조회하면 변경된 데이터를 볼 수 있습니다.
대부분의 DB 기본 격리 수준이며 REPEATABLE_READ와 함께 가장 많이 사용되는 방식입니다.
NON-REPEATABLE_READ 현상이 발생할 수 있습니다.
트랜잭션에서 조회한 데이터가 트랜잭션이 끝나기 전에 다른 트랜잭션에 의해 변경되면 다시 읽었을 때 새로운 값이 읽히며 데이터 불일치하는 현상을 말합니다.
하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 쿼리를 실행했을 때 항상 같은 결과를 가져와야 한다.
NON-REPEATABLE_READ 정합성 정의에 어긋납니다.
```
- A 트랜잭션이 데이터(Row)를 읽음.
- B 트랜잭션이 같은 데이터를 수정하고 커밋.
- A 트랜잭션이 다시 같은 데이터를 읽었는데 데이터가 달라짐.

### REPEATABLE_READ
```
간단히 말하면 하나의 트랜잭션은 하나의 스냅샷만 사용합니다.
A 트랜잭션이 시작하고 처음 조회한 데이터의 스냅샷을 저장하고 이후에 동일한 쿼리를 호출하면 스냅샷에서 데이터를 가져옵니다.
따라서 중간에 B 트랜잭션이 새로 커밋해도 A 트랜잭션이 조회하는 데이터는 변하지 않습니다.
Phantom Read라는 다른 트랜잭션에서 수행한 작업에 의해 안보였던 데이터가 보이는 현상이 발생할 수 있습니다.
REPEATABLE_READ 격리 수준은 조회한 데이터에 대해서만 Shared Lock이 걸리기 때문에 다른 트랜잭션이 새로운 데이터를 추가할 수 있습니다.
```
- A 트랜잭션이 조회한 데이터는 0건.
- B 트랜잭션이 새로운 데이터를 추가하고 커밋.
- A 트랜잭션이 같은 쿼리로 다시 조회했더니 B 트랜잭션이 추가한 데이터까지 같이 조회됨.

### SERIALIZABLE
```
가장 단순하고 엄격한 격리 수준입니다.
이름 그대로 순차적으로 트랜잭션을 진행시키며 읽기 작업에도 잠금을 걸어 여러 트랜잭션이 동시에 같은 데이터에 접근하지 못합니다.
가장 안전하지만 성능 저하가 발생하기 때문에 극도의 안정성을 필요로 하지 않으면 자주 사용되지 않습니다.
```

## 2. 본인이 사용하는 프레임워크에서 Transaction 기능이 어떻게 동작하는지 정리
Spring에서 Transaction 동작원리는 다음과 같습니다.
1) Caller에서 AOP 프록시를 호출합니다. 이때 Target을 호출하지 않고 프록시를 호출합니다.
2) AOP 프록시는 트랜잭션 Advisor를 호출합니다. 이 과정에서 커밋이 되거나 롤백이 됩니다.
3) Custom Advisor가 있다면, 트랜잭션 Advisor 실행 전후로 동작합니다.
4) Custom Advisor는 Target Method를 호출하여 비즈니스 로직을 호출합니다.
5) 결과를 순서대로 리턴합니다.

Spring AOP
Spring AOP는 두 가지 방식이 있습니다.
AOP 프록시 생성 과정에서 Target 객체가 하나 이상의 인터페이스를 구현하고 있는 클래스라면 JDK Dynamic Proxy를 사용하고,
그렇지 않다면 CGLIB를 사용합니다.
```
JDK Dynamic Proxy
java.lang에 포함되어 있는 Reflection의 Proxy 클래스가 말 그대로 동적으로 생성한다고 하여 Dynamic Proxy라고 부릅니다.
Target의 인터페이스를 기준으로 Proxy를 생성한다는 것이 Dynamic Proxy의 핵심이라고 할 수 있습니다.
```
```
CGLIB(Code Generator Library)
스프링 부트는 CGLIB가 Default입니다. CGLIB는 클래스의 바이트 코드를 조작하여 Proxy 객체를 생성하는 라이브러리인데
CGLIB를 사용하여 인터페이스가 아닌 Target에 대해서 Proxy를 생성할 수 있습니다.
```
