- 트랜잭션 격리 수준이란 **동시에 여러 트랜잭션이 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것**
    - **READ UNCOMMITED**
        - 일반적인 DB에서는 거의 사용하지 않습니다.
        - 각 트랜잭션의 변경이 COMMIT이나 ROLLBACK 여부와 상관없이 다른 트랜잭션에서 조회할 수 있습니다.
        - 이 경우 Dirty Read가 발생할 수 있습니다. (INSERT 작업이 COMMIT되기 전에 READ 해버린다든가..)
    - **READ COMMITED**
        - 온라인 서비스에서 가장 많이 선택되는 격리수준으로 어떤 트랜잭션에서 데이터를 변경하더라도 커밋이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있습니다.
        - 이 경우 Dirty Read는 해결되지만 NON-REPEATABLE READ 문제가 발생할 수 있습니다.
            - NON-REPEATABLE은 하나의 트랜잭션 내에 동일한 SELECT 쿼리를 실행했을 때 항상 같은 결과를 보장해야하는 REPEATABLE READ 정합성에 어긋나는 것을 말한다. (ACID의 일관성에 해당하는 듯?)
            - 일반 애플리케이션에서는 딱히 문제가 있지 않지만, 하나의 트랜잭션에서 동일한 데이터를 여러 번 읽고 변경하는 작업이 금전적인 처리와 연결되면 문제가 될 수 있다.
            
            
            ![Untitled]([https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cabc3a8f-94d5-428e-83fc-cfed572ffc1c/Untitled.png](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/cabc3a8f-94d5-428e-83fc-cfed572ffc1c/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221015%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20221015T010429Z&X-Amz-Expires=86400&X-Amz-Signature=55ceca6838b1b72c45c909f53d9e06642ae900ac236927e1560f58becc4a9fd1&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject))
            
            - 예를들어, 다른 트랜잭션에서 입금과 출금 처리를 계속 진행하고 있을 때 다른 트랜잭션에서 오늘 입금된 금액의 총합을 조회한다고 가정했을 때, READ COMMITED 격리 수준을 사용한다면 REPEATABLE READ가 보장되지 않으므로 총합을 계산하는 SELECT 쿼리를 실행할때마다 다른 결과를 가져오는 문제가 발생할 수 있다.
    - **REPEATABLE READ**
        - MySQL의 InnoDB 스토리지 엔진에서 사용하는 격리 수준이다. READ COMMITED 격리 수준에서 발생하는 NON-REPEATABLE READ 부정합이 발생하진 않지만 **PHANTOM READ 부정합**이 발생한다. (InnoDB 스토리지 엔진을 사용하면 피할 수 있음)
        - 일단 NON-REPEATABLE 해결 내용부터 보면, Undo 영역에 백업된 이전 데이터를 통해 트랜잭션 내에서는 동일한 결과를 보여주도록한다.
        - PHANTOM READ 부정합 : SELECT.. FOR UPDATE와 같은 쓰기 잠금을 거는 경우 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안 보였다가하는 현상을 말한다.
            
            ![Untitled]([https://s3-us-west-2.amazonaws.com/secure.notion-static.com/85e96bd0-b76f-4699-a238-0c688d305ce5/Untitled.png](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/85e96bd0-b76f-4699-a238-0c688d305ce5/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221015%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20221015T010445Z&X-Amz-Expires=86400&X-Amz-Signature=c4d68cc22ae25d5f232850435ec6ac236870af397f3daecf478ad9e1f5e110bc&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject))            
        - 원래 의도대로면 동일한 트랜잭션 내에 실행한 동일한 쿼리는 항상 같은 결과를 출력해야하지만 두 개의 SELECT … WHERE FOR UDPATE는 다른 결과를 내뱉고 있다. 이유는 SELECT…FOR UPDATE 쿼리의 경우 언두 영역에 잠금을 걸 수 없다.(SELECT하는 레코드에 쓰기 잠금을 걸어야하는데..!) 그래서 어쩔 수 없이 `SELECT ... FOR UPDATE`나 `SELECT...LOCK IN SHARE MODE`로 조회되는 레코드는 언두 영역의 변경 전 데이터를 가져오는 것이 아니라 현재 레코드 값을 가져온다.
            - [InnoDB 스토리지 엔진에서의 해결법] → 나중에 알아두자. 면접에서는 안 물어볼 듯
    - **SERIALIZABLE**
        - 이 역시 동시성이 중요한 DB에서는 거의 사용되지 않습니다. 가장 엄격한 격리 수준이기 때문에 동시 처리가 거의 불가능하다.
    
     ****
