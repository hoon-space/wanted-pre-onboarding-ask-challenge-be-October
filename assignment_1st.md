## 트랜잭션 isolation 레벌 정리
1. 커밋되지 않은 읽기
    - 트랜잭션의 변경 내용이 커밋이나 롤백 여부에 상관 없이 다른 트랜잭션에서 값을 읽을 수 있음.
    - 정합성에 문제가 많은 격리 수준이기 때문에 사용하지 않는 것을 권장
    - 더티 리드 발생 : 트랜잭션 작업이 완료되지 않았는데도, 다른 트랜잭션에서 볼 수 있는 현상

2. 커밋된 읽기
    - 커밋된 데이터만 읽을 수 있는 트랜잭션의 격리 수준.
    - 더티 리드가 발생하지 않음.
    - 실제 테이블 값을 가져오는 게 아닌, Undo 영역에 백업된 레코드에서 값을 가져온다.(변경 전 값을 읽음)
    - 하나의 트랜잭션 내에서 똑같은 select 쿼리를 실행했을 때는 항상 같은 결과값을 가져와야 하지만 Undo 영역을 읽었다가 -> 커밋 후 -> 다시 읽을 경우 다른 결과값이 조회가 되는 문제가 발생함 -> 이는 Reapeatable read 정합성에 어긋남

3. 반복가능한 읽기
    - 트랜잭션마다 트랜잭션 ID를 부여함으로써, 트랜잭션 ID보다 작은 트랜잭션 번호에서 변경한 것만 읽게 함.
    - Undo 공간에 백업해두고, 실제 레코드값 변경(이 때 변경 요청한 트랜잭션 ID는 조회하는 트랜잭션의 ID보다 크다고 가정)
        조회 트랜잭션이 레코드값을 조회해도 자신보다 작은 트랜잭션 ID의 값만 조회하므로, Undo 영역의 값이 조회됨.
    - 하지만, Phantom read라는 정합성 문제가 발생할 수 있다.
        > Phantom Read
        > 하나의 트랜잭션에서 update 명령이 유실되거나 덮어써질 수 있는 현상.
        > 즉, update 후, commit하고 다시 조회를 했을 때 예상과는 다른 값이 보이거나 데이터가 유실된 경우를 phantom read라고 함

4. 직렬화
    - 가장 단순하지만 엄격한 격리 수준
    - 성능 측면에서는 동시 처리 성능이 가장 낮음.
    - Phantom Read가 발생하지 않지만 DB에서 거의 사용되지 않음.



## Spring Boot 프레임워크에서의 Transaction
### @Transactional 기반 트랜잭션 동작 과정
> AOP의 프록시 패턴을 이용하기 때문에, @Transactional이 선언된 클래스의 비즈니스로직은 프록시객체를 통해 호출됨.

외부 트랜잭션 1개 + 내부 트랜잭션 1개인 경우

#### 외부 트랜잭션
1. 외부 트랜잭션의 프록시 객체가 Transaction Manager에게 트랜잭션 시작 요청
2. Transaction Manager가 데이터 소스의 커넥션 풀에서 커넥션을 한개 꺼냄
3. 커넥션에 `set.Autocommit(false)`설정
4. 설정된 커넥션을 Transaction 동기화 Manager에 보관
5. Transaction Manager가 외부 트랜잭션이 "새로운 트랜잭션임을 표시"함
6. 프록시가 진짜 비즈니스 로직 호출
7. 비즈니스 로직 내의 DB 로직(있다고 가정) 호출
8. Transaction 동기화 Manager에 있던 커넥션을 꺼내와서 로직 수행 후 반납

#### 내부 트랜잭션 - 커밋
9. 내부 트랜잭션의 프록시 객체가 Transaction Manager에게 트랜잭션 시작 요청
10. Transaction 동기화 Manager에 커넥션이 있는지 조회
11. 있기 때문에, 내부 트랜잭션을 "새로운 트랜잭션이 아님을 표시"함
12. 프록시가 비즈니스 로직 호출 -> DB 로직 호출 -> 동기화 Manager의 커넥션을 사용 후 반납
13. 내부 트랜잭션은 신규 트랜잭션이 아니기 때문에 커밋을 호출하지 않음

14. 외부 트랜잭션 커밋
15. Transaction Manager가 커넥션에 커밋을 요청하고, 커넥션을 커넥션 풀에 반납
16. 트랜잭션 종료


#### 만약 내부 트랜잭션이 롤백될 경우
12. 내부 로직에서 롤백이 발생 -> Transaction Manager에게 롤백 요청
13. Transaction Manager가 커넥션에 `rollbackOnly=true`로 설정

14. 외부 트랜잭션 커밋
15. 커넥션에 `rollbackOnly=true`가 설정되어 있기 때문에, 커밋되지 않고 롤백 됨
16. 트랜잭션 종료

