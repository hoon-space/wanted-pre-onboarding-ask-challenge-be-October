## 트랜잭션 격리 수준(isolation level)
### 트랜잭션 격리수준이란?
> 트랜잭션 격리수준(isolation level)이란 동시에 여러 트랜잭션이 처리될 떄, 트랜잭션끼리 얼마나 서로 고립되어 있는지를 나태내는 것이다.  
> 즉, 간단하게 말해 특정 트랜잭션이 다른 트랜잭션에 변경한 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것이다.  

데이터베이스는 ACID 특징과 같이 트랜잭션이 독립적인 수행을 하도록 Locking을 통해, 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하도록 막는 것이 필요하다.

하지만 무조건 Locking으로 동시에 수행되는 수많은 트랜잭션들을 순서대로 처리하는 방식으로 구현하게 되면 데이터베이스의 성능은 떨어지게 된다. 하지만, 성능을 높이기 위해 Locking의 범위를 줄인다면, 잘못된 값이 처리될 문제가 발생 할 수 있다.

따라서 최대한 효율적인 Locking 방법이 필요하다.

### Lock
- Lock : 트랜잭션 처리의 순차성을 보장하기 위한 방법(동시성 제어)  
    DBMS 마다 Lock을 구현하는 방식이 다르기 때문에 DBMS를 효과적으로 이용하기 위해서 해당 DB의 Lock에 대한 이해가 요구된다.
    - 공유(shared) lock : 데이터를 읽을 때 사용되어 지는 lock.
        - 공유락은 공유락끼리 동시에 접근이 가능하다. 하지만, 공유락이 설정된 데이터에 배타락을 사용할 수는 없다.
    - 배타(Exclusive) lock : 데이터를 변경하고자 할 때 사용되며, 트랜잭션이 완료될 떄까지 유지된다.
        - Lock이 해제될 떄까지 다른 트랜잭션(읽기 포함)은 해당 리소스에 접근할 수 없다.
        - 해당 Lockdms 트랜잭션이 수행되고 있는 데이터에 대해서는 접근하여 함꼐 Lock을 설정할 수 없다.
    
### 격리 수준
- READ UNCOMMITTED (레벨 0)
    - SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 계층
    - 트랜잭션에 처리중이거나, 아직 Commit되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용함
    - 데이터베이스의 일관성을 유지하는 것이 불가능함
    - Dirty Read 발생 => 데이터 정합성에 문제발생
- READ COMMITTED (레벨 1)
    - SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리는 계층
    - 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 됨
    - Commit이 이루어진 트랜잭셔만 조회 가능
    - Non-Repeatable Read 발생
- REPEATABLE READ (레발 2)
    - 트랜잭션이 완료될 때까지 SELECT 문장이 사용되는 모든 데이터에 Shared Lock이 걸리는 계층
    - 트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장함
    - 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 불가능
    - Non-Repeatable Read 부정합이 발생하지 않음
    - 자신의 트랜잭션 번호보다 낮은 트랜잭션 번호에서 변경된(커밋된) 것만 보게 된다.
    - Phantom Read 발생
- SERIALIZABLE (레발 3)
    - 트랜잭션이 완료될 떄까지 SELECT 문장이 사용되는 모든 데이터에 Shared Lock이 걸리는 계층
    - 가장 엄격한 격리 수준으로 완벽한 읽기 일관성 모드를 제공함
    - 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 및 입력 불가능

아래로 내려갈수록 트랜잭션간 고립 정도가 높아지며, 성능이 떨어지는 것이 일반적이다.  
일반적인 온라인 서비스에서는 ```READ COMMITTED```나 ```REPEATABLE READ``` 중 하나를 사용한다.  
(oracle = READ COMMITTED, mysql = REPEATABLE READ)

### 선택 시 고려사항
Isolation Level에 대한 조정은, 동시성과 데이터 무결성에 연관되어 있다.
```
동시성을 증가시키면 데이터 무결성에 문제가 발생하고, 데이터 무결성을 유지하면 동시성이 떨어지게 된다.
=> 트레이드 오프
```
