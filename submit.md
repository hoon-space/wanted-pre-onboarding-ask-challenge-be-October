1. 트랜잭션 격리레벨 정리

아래 4개의 격리레벨은 고립의 수준이 점점 높아진다.

- READ UNCOMMITTED [커밋되지 않은 읽기]

이 격리수준에서는 각 트랜잭션의 변경내용이 커밋이나 롤백여부와 
상관없이 다른 트랜잭션에서 보여지게된다.
존재하지 않는 db를 읽어오는 더티리드 이슈가 발생할 수 있다.

- READ COMMITTED [커밋된 읽기]

커밋이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있다.
따라서 더티리드 이슈는 발생하지 않는다.
트랜잭션 내에서 동일한 SELECT 쿼리를 실행했을 때 
항상 같은 결과를 보장해야한다는 REPEATABLE READ 정합성에 어긋나는
NON-REPEATABLE READ 이슈가 발생할수있다.

- REPEATABLE READ [반복 가능한 읽기]

mysql의 innoDB스토리지 엔진에서 기본으로 사용되는 격리수준.
UNDO 영역에 백업된 이전 데이터를 통해
트랜잭션 내에서는 동일한 결과를 보여주도록 보장하기때문에
NON-REPEATABLE READ 이슈는 발생하지 않지만
UNDO영역에는 잠금을 걸 수 없기때문에 UNDO영역의 변경 전 데이터가아닌
현재 레코드의 값을 가져온다 따라서
SELECT ... FOR UPDATE 쿼리 같은 쓰기 잠금을 거는 경우
다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안보였다가 하는
PHANTOM READ 부정합 이슈가 발생할 수 있다.

- SERIALIZABLE [직렬화]

가장 엄격한 격리수준.
읽고 쓰는 레코드를 다른트랜잭션에서는 절대 접근할 수 없게 되므로
모든 부정합 문제가 발생하지 않게되지만
동시처리가 거의 불가능해 처리 성능이 떨어진다.


2. 본인이 사용하는 프레임워크에서 transaction 기능이 어떻게 작동하는지

spring에서 transational 어노테이션을 발견하면 
CGlib라이브러리의 도움을 받아 런타임시점에 그 빈의 다이나믹 프록시를 만들고
프록시 객체는 트랜잭션 매니저에 접근하여 트랜잭션이나 커넥션을 열고닫도록 요청한다
트랜잭션 매니저는 jdbc방식으로 코드를 실행해서 처리한다.

