# 1. 트랜잭션 isolation 레벌 정리

- 트랜잭션은 약한것 부터 강한 것까지  read uncommited, read commited, repeatable read, serializable이 있습니다.
    - read uncommited는 더티 리드, nonreapeable 리드,팬텀 리드 문제가 발생할수 있습니다.
    - read commited 는 nonreapeable 리드,팬텀 리드 문제가 발생할수 있습니다.
    - repeatable read는 팬텀 리드 문제가 발생할수 있습니다.
    - serilalizable은 위 문제를 모두 해결합니다.
- 그렇다면 각각 격리수준과 발생하는 문제를 하나씩 살펴보도록 하죠.
    - read uncommited는 커밋이 안된 데이터도 다른 트랜잭션이 볼수 있습니다.  이런 것을 더티 리드라고 합니다.
    - 이러한 문제를 해결한 것은 read commited 입니다. 이것은 커밋이 된 데이터만 트랜잭션이 읽을 수있도록 설정된 격리 수준입니다. 이 수준에서는 nonrepeatable 리드 문제가 있을 수 있습니다.
    - nonrepeatable 리드는 테이블의 특정 행의 데이터가 같은 트랜잭션 내에서 읽은 시점에 따라 그 값이 다르다는 문제입니다.
    - 이 문제를 해결한 것이 repeatable read 격리 수준 입니다. 이 수준에서는 undo영역을 활용하여 변경 전의 행의 데이터를 따로 관리하기 때문에 다시 읽어도 행의 값이 같습니다.
    - 하지만 아직 해결되지 않은 문제가 있는데 이것이 팬텀 리드 문제입니다.
    - 팬텀 리드란 유령과 같이 존재하지 않던 행이 등장하는 문제입니다. 트랜잭션 내에서 두번의 select가 일어 났을때 늦게 일어난 select에서는 기존에 보이지 않던 행이 보이게 되는 현상입니다.
    - 이러한 문제는 serializable 격리 수준으로 해결할 수 있습니다. 이 수준에서는 선행 트랜잭션이 특정 테이블을 읽는 경우(`SELECT`) `공유 잠금(shared lock)` 을 걸어, 다른 트랜잭션에서 해당 테이블의 데이터를 `UPDATE`, `DELETE`, `INSERT` 작업을 못하도록 막습니다.

        이 수준에서는 특정 레코드(행)에 대한 트랜잭션은 절대 동시에 일어날 수 없습니다.

- 강한 격리 수준을 보일 수록 dbms의 성능이 떨어지기 때문에, 비즈니스 상황에 맞게 잘 설정해야 할 것입니다. 보통 rdbms의 격리 기본 값은 read commited 라고 합니다.

# 2. 본인이 사용하는 프레임워크에서 Transaction 기능이 어떻게 동작하는지 정리
아직...